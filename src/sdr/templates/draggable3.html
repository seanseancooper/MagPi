<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Spectrogram with Drag Interactions</title>
  <style>
    canvas {
      border: 1px solid #ccc;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <canvas id="cvs_xaxis" width="1024" height="50"></canvas>
  <canvas id="cvs_hl" width="1024" height="100"></canvas>

  <script>
        const fft_size = 1024;
        const sampling_rate = 2.4e6; // 2.4 MHz
        const cvs_xaxis = document.getElementById('cvs_xaxis');

        let center_freq = 915000000; // Starting center frequency in Hz
        let fft_bw = 2000000;        // Bandwidth in Hz
        let isDragging = false;
        let dragStartX = 0;
        let center_freq_at_drag_start = center_freq;


        // Get canvas width in pixels
        let canvas_width_px = cvs_xaxis.width;

        const cvs = document.getElementById('cvs_xaxis');
        const ctx = cvs.getContext('2d');


        let span = 2e6; // Frequency span in Hz

        function drawAxis() {
          ctx.clearRect(0, 0, cvs.width, cvs.height);
          ctx.fillStyle = 'black';
          ctx.fillRect(0, 0, cvs.width, cvs.height);
          ctx.fillStyle = 'white';
          ctx.font = '12px sans-serif';

          for (let i = 0; i <= 10; i++) {
            const x = (i / 10) * cvs.width;
            const freq = center_freq - span / 2 + (i / 10) * span;
            const label = (freq / 1e6).toFixed(1) + ' MHz';
            ctx.fillText(label, x - 15, 20);
          }
        }

        drawAxis();

        cvs.addEventListener('mousedown', (e) => {
          isDragging = true;
          dragStartX = e.clientX;
        });

        document.addEventListener('mouseup', () => {
          isDragging = false;
        });

        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          const dx = e.clientX - dragStartX;
          dragStartX = e.clientX;
          const freqPerPixel = span / cvs.width;
          center_freq -= dx * freqPerPixel;
          drawAxis();
        });

        cvs.addEventListener('wheel', (e) => {
          e.preventDefault();
          const scrollAmount = e.deltaY;
          const scrollFactor = 10000; // Adjust sensitivity
          center_freq += scrollAmount * scrollFactor;
          drawAxis();
        });




        // Convert between Hz and pixels
        function freqToPx(freq) {
          return ((freq - center_freq) / fft_bw + 0.5) * canvas_width_px;
        }

        function pxToFreq(px) {
          return center_freq + ((px / canvas_width_px) - 0.5) * fft_bw;
        }

        // Redraw function (replace this with your real implementation)
        function redrawXAxis() {
          const ctx = cvs_xaxis.getContext('2d');
          ctx.clearRect(0, 0, cvs_xaxis.width, cvs_xaxis.height);
          ctx.fillStyle = 'black';
          ctx.fillText(`Center: ${(center_freq / 1e6).toFixed(3)} MHz`, 10, 20);
        }

        // --- DRAG EVENTS ---
        cvs_xaxis.addEventListener('mousedown', (e) => {
          isDragging = true;
          dragStartX = e.offsetX;
          center_freq_at_drag_start = center_freq;
        });

        cvs_xaxis.addEventListener('mousemove', (e) => {
          if (!isDragging) return;

          const deltaPx = e.offsetX - dragStartX;
          const deltaFreq = -(deltaPx / canvas_width_px) * fft_bw;
          center_freq = center_freq_at_drag_start + deltaFreq;

          redrawXAxis(); // Re-render the axis
        });

        cvs_xaxis.addEventListener('mouseup', () => {
          isDragging = false;
        });

        cvs_xaxis.addEventListener('mouseleave', () => {
          isDragging = false;
        });

        // --- SCROLL EVENT ---
        cvs_xaxis.addEventListener('wheel', (e) => {
          e.preventDefault();

          const scrollStepHz = 100000; // 100 kHz per notch
          const delta = e.deltaY;

          center_freq += delta > 0 ? scrollStepHz : -scrollStepHz;

          redrawXAxis(); // Re-render the axis
        });

    function freqToX(freq) {
      const df = sampling_rate / fft_size;
      return (freq - (center_freq - sampling_rate / 2)) / df;
    }

    function draw_indicia() {
      const ctx = cvs_xaxis.getContext("2d");
      ctx.clearRect(0, 0, cvs_xaxis.width, cvs_xaxis.height);

      // Draw center line
      const centerX = cvs_xaxis.width / 2;
      ctx.strokeStyle = "red";
      ctx.beginPath();
      ctx.moveTo(centerX, 0);
      ctx.lineTo(centerX, cvs_xaxis.height);
      ctx.stroke();

      // Draw frequency labels (simple example)
      ctx.fillStyle = "black";
      ctx.font = "12px sans-serif";
      for (let i = 0; i < 5; i++) {
        let freq = center_freq + (i - 2) * sampling_rate / 4;
        let x = centerX + (i - 2) * cvs_xaxis.width / 4;
        ctx.fillText((freq / 1e6).toFixed(1) + " MHz", x - 20, 12);
      }
    }

    class Highlight {
      constructor(min_sel, max_sel, alpha, color) {
        this.min_sel = min_sel;
        this.max_sel = max_sel;
        this.alpha = alpha;
        this.color = color;
      }

      render(ctx) {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.min_sel, 0, this.max_sel - this.min_sel, ctx.canvas.height);
        ctx.restore();
      }
    }

    class HighlightLayer {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext("2d");
        this.highlights = [];
      }

      addHighlight(min_sel, max_sel, alpha, color) {
        this.highlights.push(new Highlight(min_sel, max_sel, alpha, color));
      }

      render() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.highlights.forEach(h => h.render(this.ctx));
      }
    }

    class DragManager {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.draggables = [];
        this.active = null;
        this.lastX = 0;

        canvas.addEventListener("mousedown", e => this._onMouseDown(e));
        window.addEventListener("mousemove", e => this._onMouseMove(e));
        window.addEventListener("mouseup", e => this._onMouseUp(e));
      }

      addDraggable({ hitTest, onDrag, onDragEnd = () => {} }) {
        this.draggables.push({ hitTest, onDrag, onDragEnd });
      }

      _onMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        this.lastX = x;
        for (const d of this.draggables) {
          if (d.hitTest(x)) {
            this.active = d;
            break;
          }
        }
      }

      _onMouseMove(e) {
        if (!this.active) return;
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const dx = x - this.lastX;
        this.active.onDrag(dx);
        this.lastX = x;
      }

      _onMouseUp(e) {
        if (this.active) {
          this.active.onDragEnd();
          this.active = null;
        }
      }
    }

    // Instantiate DragManager for frequency axis
    const dragAxis = new DragManager(cvs_xaxis);
    dragAxis.addDraggable({
      hitTest: x => Math.abs(x - cvs_xaxis.width / 2) < 6,
      onDrag: dx => {
        const deltaFreq = dx * (sampling_rate / fft_size * (fft_size / cvs_xaxis.width));
        center_freq += deltaFreq;
        draw_indicia();
      }
    });

    draw_indicia();

    // Highlights Setup
    const hlLayer = new HighlightLayer("cvs_hl");
    const dragHl = new DragManager(hlLayer.canvas);

    const highlights = [
      { min_sel: 200, max_sel: 300, alpha: 0.3, color: "blue" },
      { min_sel: 600, max_sel: 700, alpha: 0.3, color: "green" }
    ];

    highlights.forEach(h => {
      hlLayer.addHighlight(h.min_sel, h.max_sel, h.alpha, h.color);
      const [hlInstance] = hlLayer.highlights.slice(-1);

      dragHl.addDraggable({
        hitTest: x => Math.abs(x - hlInstance.min_sel) < 6,
        onDrag: dx => {
          hlInstance.min_sel = Math.max(0, hlInstance.min_sel + dx);
          hlLayer.render();
        }
      });

      dragHl.addDraggable({
        hitTest: x => Math.abs(x - hlInstance.max_sel) < 6,
        onDrag: dx => {
          hlInstance.max_sel = Math.min(cvs_hl.width, hlInstance.max_sel + dx);
          hlLayer.render();
        }
      });
    });

    hlLayer.render();
  </script>
</body>
</html>
