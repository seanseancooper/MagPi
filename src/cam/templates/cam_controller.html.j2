<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CAMController</title>
    <style>
        /* Ensure the size of the image fit the container perfectly */
        canvas {
          display: block;

          /* This rule is very important, please don't ignore this */
          max-width: 100%;
        }
    </style>

    <link rel="stylesheet" href="{{ url_for('cam_bp.static', filename='css/cropper.css') }}">
    <link rel="stylesheet" href="{{ url_for('cam_bp.static', filename='css/cam_controller.css') }}">
    <script src="{{ url_for('cam_bp.static', filename='js/cam_controller.js') }}"></script>
    <script>

        function setsHeaders(xhttp) {
            xhttp.setRequestHeader('Access-Control-Allow-Origin', 'localhost:*');
            xhttp.setRequestHeader('Access-Control-Allow-Methods', 'POST, GET');
            xhttp.setRequestHeader('Content-Type', 'text/html');
            xhttp.setRequestHeader('Access-Control-Allow-Headers', 'Content-Type, Access-Control-*, majic-color');
        }

        function load_video(){
            var _video = document.getElementById("_video");

            while (_video.src != "http://localhost:6100/stream") {
                _video.src = "http://localhost:6100/stream";
            }
        }

        function fore_aft(button){
            // changes fore/aft view
            var xhttp = new XMLHttpRequest();
            xhttp.open('POST', '{{ url_for('.index')}}view/' + button.value);
            setsHeaders(xhttp);
            xhttp.send(); // no response

            button.value = (button.value == "FORE")? "AFT": "FORE";
            document.getElementById("fore_aft_button").innerHTML = button.value.split('')[0];
            document.getElementById("fore_aft_button").classList.value = "fore_aft_button";

            setTimeout(function() {
                load_video();
            }, 10);
        }

        function cam_multibutton(button){
            // set symbology & analysis
            const xhttp = new XMLHttpRequest();
            xhttp.open('POST', "{{ url_for('.index')}}multibutton/" + button.value);
            setsHeaders(xhttp);
            xhttp.send();

            xhttp.onload = function() {
                const resp = xhttp.response;
                document.getElementById("multi_button").value = resp;
                document.getElementById("multi_button_text").innerHTML = resp;
            }
        }

        function handleCropper(cropper) {
            // send crop
            const cropper_output = document.getElementById(cropper.id.replace('_input', '_output'));

            function updateCropper() {
                var component = cropper.id.replace('_input', '');

                const xhttp = new XMLHttpRequest();
                xhttp.open('POST', '{{ url_for('.index')}}plugin/' + component + "/" + cropper.value);
                setsHeaders(xhttp);
                xhttp.send();

                xhttp.onload = function() {
                    if (xhttp.response == "OK"){
                        var j = JSON.parse(cropper.value);
                        cropper_output.innerText = "x:" + j['x'] +
                                                  " y:" + j['y'] +
                                                  " w:" + j['w'] +
                                                  " h:" + j['h'];
                    }
                };
            }

            updateCropper();
        }



        function handleSlider(slider) {
            // handle continous
            const slider_output = document.getElementById(slider.id.replace('_input', '_output'));

            function updateSlider() {
                var component = slider.id.replace('_input', '');
                //draw_grid([slider.value, slider.value], '#00F', 1);
                const xhttp = new XMLHttpRequest();
                xhttp.open('POST', '{{ url_for('.index')}}plugin/' + slider.id.replace('cam_slider_', '').replace('_input', '') + "/" + parseFloat(slider.value));
                setsHeaders(xhttp);
                xhttp.send();

                xhttp.onload = function() {
                    if (xhttp.response == "OK") {
                        slider_output.innerText = slider.value;
                        slider.addEventListener('input', updateSlider);
                    }
                };
            }

            updateSlider();
        }



        function handleGridSlider(slider) {
            const grid = document.getElementById("grid");


            document.querySelector('#cam_slider_krnl_input')
                .addEventListener('input', evt => {

                const slider_output = document.getElementById(slider.id.replace('_input', '_output'));
                grid.style.setProperty('display','block');
                const ctx = grid.getContext("2d");
                const range = (start, stop, step) => Array.from({ length: (stop - start) / step + 1}, (_, i) => start + (i * step))
                const slider_range = 127;

                function draw_line(ctx, fx, fy, tx, ty){
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = "gray";

                    ctx.beginPath();
                    ctx.moveTo(fx, fy);
                    ctx.lineTo(tx, ty);
                    ctx.stroke();
                };

                function updateSlider() {
                    const component = slider.id.replace('_input', '');
                    const text = document.getElementById('cam_slider_krnl_output');

                    let stepSz = slider.value;
                    text.innerHTML = slider.value;

                    let hw = grid.width/2;
                    let hh = grid.height/2;
                    let hs = stepSz/2;
                    let hsl = slider_range/2

                    var pos_heights = range(0, grid.height, hs);
                    var pos_widths = range(0, grid.width, hs);

                    ctx.clearRect(0, 0, grid.width, grid.height);
                    ctx.save();

                    ctx.translate(hw, hh);
                    ctx.fillRect(-4, -4, 8, 8);

                    for(i=0; i<2; i++){

                        for (y=0; y < pos_heights.length; y++) {
                            draw_line(ctx, -grid.height, pos_heights[y], grid.height, pos_heights[y]);
                        };

                        for (x=0; x < pos_widths.length; x++) {
                            draw_line(ctx, pos_widths[x], -grid.width,  pos_widths[x], grid.width);
                        }
                        ctx.rotate(180 * Math.PI / 180);
                    }
                    // Restore the transform
                    ctx.restore();


                }
                updateSlider();
            });
            grid.style.setProperty('display','none');
        }

        function handleCheckBox(checkbox) {
            // handle binary
            const cb_output = document.getElementById(checkbox.id.replace('_input', '_output'));

            function updateCheckBox() {
                var component = checkbox.id.replace('_input', '');

                const xhttp = new XMLHttpRequest();
                xhttp.open('POST', '{{ url_for('.index')}}plugin/' + checkbox.id.replace('cam_checkbox_', '').replace('_input', '') + "/" + checkbox.checked);
                setsHeaders(xhttp);
                xhttp.send();

                xhttp.onload = function() {
                    if (xhttp.response == "OK") {
                        cb_output.innerText = (checkbox.checked)? "ON": "OFF";
                    }
                };
            }

            updateCheckBox();
        }

        function cam_snap(){
            //  creates still image of current view
            const xhttp = new XMLHttpRequest();
            xhttp.open('POST', '{{ url_for('.index')}}snap');
            setsHeaders(xhttp);
            xhttp.send();

            // on response, run the videobutton animation
            xhttp.onload = function() {
                const resp = xhttp.response;
                var snapButton = document.getElementById('snap_button_text');

                if (resp == "OK"){
                    snapButton.classList.value = "snap_button_text";
                    snapButton.innerHTML = "x";
                    setTimeout(function() {
                        snapButton.innerHTML = "+";
                    }, 250);
                }
            };
        };
    </script>
</head>
<body>
<div>

    <div id="videodiv" class="videodiv" style="width:{{ plugin.frame_shape[1] }}px;height:{{ plugin.frame_shape[0] }}px;">
        <iframe id="_video" style="width:{{ plugin.frame_shape[1] }}px;height:{{ plugin.frame_shape[0] }}px;" class="_video" src="" onLoad="load_video();"></iframe>
        <canvas id="target" class="_target" style="width:{{ plugin.frame_shape[1] }}px;height:{{ plugin.frame_shape[0] }}px;"></canvas>
        <canvas id="grid" class="_grid" width="{{ plugin.frame_shape[1] }}" height="{{ plugin.frame_shape[0] }}"></canvas>
    </div>

    <script src="{{ url_for('cam_bp.static', filename='cropperjs/dist/cropper.js') }}"></script>
    <script>
        window.addEventListener('DOMContentLoaded', function () {
            var image = document.querySelector('#target');
            var cropper = new Cropper(image, {
                viewMode: 1,
                center: true,
                dragMode: 'move',
                zoomable: false,
                scalable: false,
                autoCropArea: .50,
                restore: false,
                modal: false,
                cropBoxMovable: true,
                cropBoxResizable: true,
                toggleDragModeOnDblclick: false,
                cropend: function (event) {
                    cropper.getData();
                    var cropBoxData = cropper.getCropBoxData();

                    var c = Object();
                    c.id = 'crop_input';

                    value = {
                        'x': Math.round(cropBoxData.left),
                        'y': Math.round(cropBoxData.top),
                        'w': Math.round(cropBoxData.width),
                        'h': Math.round(cropBoxData.height)
                    }

                    c.value = JSON.stringify(value);
                    handleCropper(c);
                }
            });
       });
    </script>

    <div id="top_buttons" style="" class="top_buttons highlight">
       <button id="fore_aft_button" class="button" value="AFT" onClick="fore_aft(this);">
            <div id="fore_aft_button_text" style="">A</div>
        </button>
        <button id="multi_button" style="position:relative;top:-3px;" class="button" value="OFF" onClick="cam_multibutton(this);">
            <div id="multi_button_text" style="font-size:12px;color:#333;position:relative;left:-2px;top:1px;" class="multi_button_text">OFF</div>
        </button>
        <button id="snap_button" style="position:relative;top:-1px;" class="button"  value="SNAP" onClick="cam_snap();">
            <div id="snap_button_text" style="" class="snap_button_text">+</div>
        </button>
        <button id="silence_button" style="position:relative;top:0px;" class="button"  value="SILENCE" onClick="cam_silence();">
            <div id="silence_button_text" style="position:relative;left:-1px;top:1px;" class="silence_button_text">!</div>
        </button>
        <button id="erase_button" style="text-align:center;position:relative;top:-1px;left:562px" class="button">
            <div id="erase_button_text" style="top:1px;color:red;" class="erase_button_text">!</div>
        </button>
        {% include 'audio_player.html.j2' ignore missing %}
    </div>

    <div id="info_box" style="" class="">
        <div id="cam_slider_outputs" style="" class="cam_slider_outputs highlight">
                ∑:&nbsp;<span id="cam_slider_threshold_output">{{ plugin.threshold | int }}</span>
                ∞:&nbsp;<span id="cam_checkbox_hold_threshold_output">OFF</span>
                ⊞:&nbsp;<span id="cam_slider_krnl_output">{{ plugin.krnl }}</span>
            <br>
                ƒL:&nbsp;<span id="cam_slider_f_limit_output">{{ plugin.tracker.f_limit }}</span>
                ƒ%:&nbsp;<span id="cam_slider_frm_delta_pcnt_output">{{ "{:.2f}".format(plugin.tracker.frm_delta_pcnt) }}</span>
            <br>
                <span id="crop_output" class="cam_slider_crop_stats">x:0 y:0 w:0 h:0</span>
        </div>
    </div>

    <span id="cam_sliders" style="" class="cam_sliders highlight">
        <div id="cam_checkbox_hold_threshold" style="position:absolute;left:0px;">
            <input id="cam_checkbox_hold_threshold_input" style="position:absolute;left:-20px;top:98px;" type="checkbox" {{ "checked" if plugin.hold_threshold is true }} onChange="handleCheckBox(this);"/>
        </div>
        <div id="cam_slider_threshold" style="position:absolute;left:0px;">
            ∑<br><input id="cam_slider_threshold_input" style="height:100px;" class="cam_slider" orient="vertical" type="range" min="-100" max="100" step="1" value="{{ plugin.threshold | int }}" onChange="handleSlider(this);"/>
        </div>
        <div id="cam_slider_krnl" style="position:absolute;top:0px;left:25px;">
            ⊞<br><input id="cam_slider_krnl_input" style="" class="cam_slider" orient="vertical" type="range" min="1" max="128" step="2" value="{{ plugin.krnl }}" onChange="handleGridSlider(this);"/>
        </div>
        <div id="cam_slider_f_limit" style="position:absolute;top:0px;left:50px;">
            ƒL<br><input id="cam_slider_f_limit_input" style="" class="cam_slider" orient="vertical" type="range" min="1" max="60" step="1" value="{{ plugin.tracker.f_limit }}" onChange="handleSlider(this);"/>
        </div>
        <div id="cam_slider_frm_delta_pcnt" style="position:absolute;top:0px;left:100px;">
            ƒ%<br><input id="cam_slider_frm_delta_pcnt_input" style="" class="cam_slider" orient="vertical" type="range" min="0.00" max="100.00" step="0.01" value="{{ plugin.tracker.frm_delta_pcnt | float }}" onChange="handleSlider(this);"/>
        </div>
    </span>
</div>
</body>
</html>
